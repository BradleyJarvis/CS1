<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="PrivateKeyExplanationTextBox.Text" xml:space="preserve">
    <value>Now  we have  looked at how a simple substitution cipher can be used to protect information. We used symmetrical key algorithms. What this means is that both parties require a copy of the key in order to read the message. Any person who intercepts a message between the two will not know what it says. While it is true that they can break through this encryption, it will take time (the amount of time depends on the algorithm). 

The example to the right uses a Caesar Shift, enter the text, choose the amount to shift by and click send to see how it works with a hacker listening in.</value>
  </data>
  <data name="FindCommontextBox.Text" xml:space="preserve">
    <value>Now comes the most important part. Both the sender and the receiver take the number that they received and raise it to the power of their secret number then find the remainder when divided by 17 , so that’s Received^Secret MOD 17. This will give the same result for both the sender and the receiver. Press “Find common number” to find the number that the sender and receiver now know. It is worth noting that the hacker has received the same information that was sent but without either secret number they cannot know the commonly found number without a very large amount of computing time.</value>
  </data>
  <data name="ReplytextBox.Text" xml:space="preserve">
    <value>The receiver then does the same by finding the 3^x MOD 17 where x is his secret number. and sends this as a response. Once again the hacker listens in on this communication. Press “Reply” to work out the answer to the MOD equation and send it.</value>
  </data>
  <data name="PrivateKeyStepOneTextBox.Text" xml:space="preserve">
    <value>If you look below there is an example of the solution to this conundrum. The algorithm  in this case uses the numbers 3 and 17 because they share no common factors. It is very important that they are prime numbers. The reason is because of a mathematical operation called MOD. What  this operation does is find out what the remainder is when two numbers are divided. For example 20 divided by 6 would be 3 remainder 2 because 6 x 3 is 18 and 18 is 2 away from 20, therefore we can say that 20 MOD 6 = 2. The interesting thing about this function is that when you take a prime number raised to a power and MOD it with another prime number the result changes a lot depending on what the power was. For example :
3^4 MOD 17 = 13		3^5 MOD 17 = 5		3^6 MOD 17 = 15
These results are very different and the most important thing is that given the number 15 it is very hard to find out what the power of 3 was. 
Using the numbers 3 and 17 means that a number between 0 and 16 can be stored (because of the 17) and that the answer can probably be found relatively quickly due to the fact 3 is a small number. However in real applications prime numbers that are thousands bits, truly huge numbers. This way, even though it is possible to crack, the time required is extreme and more importantly there is no quick way to do it.</value>
  </data>
  <data name="PrivateKeyIntroductionTextBox.Text" xml:space="preserve">
    <value>In the previous section we have two people who each had a access to a secret key that they both used, however the problem with this is both parties must secretly decide what the key will be and they must also ensure that no one else knows it. This is fine if you want to communicate to a friend but if you are wanting to communicate with someone you can’t physically exchange the key with, how will you be able tell it to each other without the hacker also finding it.

To solve this problem computer scientists came up with an algorithm that is easy to compute an answer for but that is difficult to undo unless you are the person who the message was intended for or the person it was sent by. What's more the algorithm must still be hard to undo even when someone knows what the algorithm is.

This may sound impossible but the maths involved is quite simple. It is called the Diffie–Hellman key exchange.</value>
  </data>
  <metadata name="$this.TrayHeight" type="System.Int32, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089">
    <value>68</value>
  </metadata>
</root>